package com.github.orbyfied.carbon.content.pack;

import com.github.orbyfied.carbon.Carbon;
import com.github.orbyfied.carbon.bootstrap.CarbonBranding;
import com.github.orbyfied.carbon.config.AbstractConfiguration;
import com.github.orbyfied.carbon.config.Configurable;
import com.github.orbyfied.carbon.config.Configure;
import com.github.orbyfied.carbon.content.AssetPreparingService;
import com.github.orbyfied.carbon.content.pack.host.PackHostProvider;
import com.github.orbyfied.carbon.content.pack.host.PackHostServer;
import com.github.orbyfied.carbon.logging.BukkitLogger;
import com.github.orbyfied.carbon.process.Process;
import com.github.orbyfied.carbon.process.impl.ParallelTask;
import com.github.orbyfied.carbon.process.impl.QueuedTickExecutionService;
import com.github.orbyfied.carbon.process.impl.SyncTask;
import com.github.orbyfied.carbon.registry.Registry;
import com.github.orbyfied.carbon.util.resource.ResourceHandle;
import net.md_5.bungee.api.ChatColor;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.BiConsumer;
import java.util.function.Function;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class ResourcePackManager {

    /**
     * The main Carbon instance.
     */
    private final Carbon main;

    /**
     * The logger.
     */
    private final BukkitLogger logger;

    public final Path packSrcDirectory;

    public final Path packPkgFile;

    public Path packPkgFileNamed;

    protected PackHostProvider hostServer;

    protected Configurable<HostConfig> hostConfig = Configurable.of("resource-pack-host", HostConfig::new);

    protected Configurable<BuilderConfig> builderConfig = Configurable.of("resource-pack-builder", BuilderConfig::new);

    public ResourcePackManager(Carbon main) {
        this.main   = main;
        this.logger = main.getLogger("ResourcePack");
        this.packSrcDirectory = main.getFileInDirectory("resource_pack/src/");
        this.packPkgFile      = main.getFileInDirectory("resource_pack/pack.zip");
        packPkgFileNamed      = main.getFileInDirectory("resource_pack/Carbon Mod Resources.zip");

        main.getConfigurationHelper()
                .addConfigurable(hostConfig)
                .addConfigurable(builderConfig);
    }

    public Carbon getMain() {
        return main;
    }

    public BukkitLogger getLogger() {
        return logger;
    }

    public PackHostProvider getHostServer() {
        return hostServer;
    }

    public CompletableFuture<ResourcePackManager> build() {

        final CompletableFuture<ResourcePackManager> future = new CompletableFuture<>();

        new Thread(() -> {

            int modCount = main.getModLoader().getMods().size();
            logger.info("Building resource pack for " + modCount + " mods.");

            // delete old resource pack and create new
            try {

                // delete old
                Files.deleteIfExists(packPkgFile);
                Files.deleteIfExists(packPkgFileNamed);
                deleteDirectory(packSrcDirectory);

                // create new
                Files.createDirectories(packSrcDirectory);

            } catch (IOException e) {
                e.printStackTrace();
                return;
            }

            // prepare assets
            logger.stage("Prepare");

            // create pack builder
            ResourcePackBuilder b = new ResourcePackBuilder(this, packSrcDirectory);

            // collect asset building services
            ArrayList<AssetPreparingService> serviceList = new ArrayList<>();
            for (Registry<?> reg : main.getRegistries())
                serviceList.addAll(reg.getServicesOf(
                        AssetPreparingService.class,
                        serviceList));

            logger.debugc("Found " + serviceList.size() + " asset providing registry services.");
            logger.debugc("Preparing assets.");

            // prepare assets from services
            for (AssetPreparingService s : serviceList)
                s.prepareAssets(b);

            // prepare mcmeta
            b.asset((Function<ResourcePackBuilder, PackMetaBuilder>) PackMetaBuilder::new)
                    .setDescription(ChatColor.DARK_GRAY + "Generated by " + CarbonBranding.PREFIX +
                            ChatColor.WHITE + " for " + ChatColor.YELLOW + modCount +
                            ChatColor.WHITE + " mods.")
                    .setPackFormat(main.getPlatform().getResourcePackProxy().getPackFormat());

            // prepare copy pack.png
            b.asset(new CopyAssetBuilder(b, PackResource.of("packpng", p -> p.resolve("pack.png"))))
                    .setSource(ResourceHandle.ofModuleResource("/carbon/content.pack/pack.png"));


            logger.debugc("Prepared " + b.assets.size() + " assets.");
            logger.debugc("Building pack on " + builderConfig.getConfiguration().threads + " threads.");

            BiConsumer<Process<PackAssetBuilder>, PackAssetBuilder> worker =
                    (proc, builder) -> {
                // get file path
                Path rp = builder.resource.getPath(b.srcDir);
                logger.debugc(() -> prefixwt("Building resource " + builder.resource.getName() + ": " + rp));
                try {
                    // create file
                    if (!Files.exists(rp))
                        Files.createFile(rp);

                    // open output stream and write file, then close
                    OutputStream s = Files.newOutputStream(rp);
                    builder.write(s);
                    s.close();
                } catch (Exception e) {
                    // log error
                    logger.err(prefixwt("Error while building " + builder.resource.getName() + " (" +
                            rp + "): " + e));
                    e.printStackTrace();
                }
            };

            // the starting time
            AtomicLong t1 = new AtomicLong();

            // create process
            Process<PackAssetBuilder> process = main.getProcessManager()
                    .process(worker);

            // add tasks
            process.addTasks(
                    // collect the start time
                    new SyncTask<PackAssetBuilder, Process<PackAssetBuilder>>().runnable((proc, __) -> {
                        t1.set(System.currentTimeMillis());
                    }),

                    // build all assets using worker
                    new ParallelTask<PackAssetBuilder, Process<PackAssetBuilder>>()
                            .threads(builderConfig.getConfiguration().threads)
                            .joined(true)
                            .addWork(b.assets),

                    // package and print information
                    new SyncTask<PackAssetBuilder, Process<PackAssetBuilder>>().runnable((proc, __) -> {
                        // debug
                        long tms1 = System.currentTimeMillis() - t1.get();
                        logger.debugc("Built unpacked resource pack in " + tms1 + "ms");

                        // package resource pack
                        logger.info("Packaging resource pack");
                        zipFilesInFolder(packSrcDirectory.toAbsolutePath().toString(), packPkgFile);

                        // rename/copy resource pack to the renamed file
                        try {
                            Files.copy(packPkgFile, packPkgFileNamed, StandardCopyOption.REPLACE_EXISTING);
                        } catch (IOException e) {
                            e.printStackTrace();
                        }

                        // print info
                        long tms = System.currentTimeMillis() - t1.get();
                        logger.info("Built and packaged resource pack in " + tms + "ms");

                        // call future
                        future.complete(this);

                    })
            );

            // set up executor service
            QueuedTickExecutionService service = new QueuedTickExecutionService(main.getProcessManager());
            QueuedTickExecutionService.TickLoop tickLoop = service.tickLoop(true, null);

            // set up and run process
            logger.stage("Build");
            process
                    .whenDone(tickLoop::end) // end tick loop when finished
                    .run(service);

            // run the tick loop
            tickLoop.run();

        }, "Carbon.ResourcePackBuilder").start();

        return future;

    }

    public ResourcePackManager startHost() {

        // start server
        logger.stage("Host");
        logger.info("Starting resource pack host provider.");

        try {

            String method = hostConfig.getConfiguration().strategy.toLowerCase();
            switch (method) {
                case "http" -> hostServer = new PackHostServer(this);
                default -> {
                    logger.err("Invalid host provider method: " + method.toUpperCase());
                    return this;
                }
            }

            logger.debugc("Using host provider method: " + method.toUpperCase());

            hostServer.host(packPkgFileNamed, 0);
            hostServer.start();
            hostServer.sendPackToAllPlayers(0, true);

        } catch (Exception e) {
            logger.err("Error occurred while starting pack host: " + e);
            e.printStackTrace();
        }

        return this;

    }

    ///////////////////////////////////////////////////

    class BuilderConfig extends AbstractConfiguration {

        public BuilderConfig(Configurable<?> configurable) {
            super(configurable);
        }

        @Configure
        public int threads;

    }

    class HostConfig extends AbstractConfiguration {

        public HostConfig(Configurable<?> configurable) {
            super(configurable);
        }

        @Configure
        public String strategy;

    }

    ///////////////////////////////////////////////////

    private String prefixwt(String s) {
        return ChatColor.DARK_GRAY + "{ " + Thread.currentThread().getName() + " }" + ChatColor.WHITE + " " + s;
    }

    private void deleteDirectory(Path path) throws IOException {
        if (!Files.exists(path))
            return;

        Files.walkFileTree(path, new SimpleFileVisitor<>() {

            @Override
            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
                Files.delete(dir);
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                Files.delete(file);
                return FileVisitResult.CONTINUE;
            }

        });

    }

    /**
     * From: https://www.netjstech.com/2016/06/zipping-files-in-java.html#ZipMultipleFileJava
     */
    private void zipFilesInFolder(String folder, Path resultFile){
        try {
            if (!Files.exists(resultFile))
                Files.createFile(resultFile);
            OutputStream fos = Files.newOutputStream(resultFile);
            ZipOutputStream zos = new ZipOutputStream(fos);

            Path sourcePath = Paths.get(folder);
            // using WalkFileTree to traverse directory
            Files.walkFileTree(sourcePath, new SimpleFileVisitor<Path>(){
                @Override
                public FileVisitResult preVisitDirectory(final Path dir, final BasicFileAttributes attrs) throws IOException {
                    // it starts with the source folder so skipping that
                    if(!sourcePath.equals(dir)){
                        //System.out.println("DIR   " + dir);
                        zos.putNextEntry(new ZipEntry(sourcePath.relativize(dir).toString() + "/"));
                        zos.closeEntry();
                    }
                    return FileVisitResult.CONTINUE;
                }
                @Override
                public FileVisitResult visitFile(final Path file, final BasicFileAttributes attrs) throws IOException {
                    zos.putNextEntry(new ZipEntry(sourcePath.relativize(file).toString()));
                    Files.copy(file, zos);
                    zos.closeEntry();
                    return FileVisitResult.CONTINUE;
                }
            });

            zos.close();
            fos.close();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

}
